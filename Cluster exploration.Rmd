---
title: "Cluster.exploration"
author: "Stephanie Hopkins"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: TRUE
---

```{r setup, include=FALSE}

rm(list=ls())
gc()

# remotes::install_github("pbs-assess/sdmTMB")

load.lib <- c("tidyverse", "data.table", "cowplot", "sf", "grid", "ggspatial", "ggnewscale", "RColorBrewer", "scales", "rcompanion", "rnaturalearth", "rnaturalearthhires", "r4ss", "patchwork","rmapshaper", "here", "sdmTMB", "zoo")

install.lib <- load.lib[!load.lib %in% installed.packages()]

for(lib in install.lib) install.packages(lib,dependencies=TRUE)
sapply(load.lib,require,character=TRUE)

sf_use_s2(FALSE)

dir <- here()

Figure.path <- "Figures/"

```

# Investigate LFDs and data structures

```{r, area2}

area2.poly <- read_sf(paste(dir, "Data/area2.polygons.shp", sep = ""))

plot(area2.poly)

colnames(area2.poly)

plotNormalHistogram(area2.poly$CtchWgL)
range(area2.poly$CtchWgL)

```

# Create density estimates to be used for biomass abundance indices

Note that here we want to include the absence data and are not concerned by lengths

```{r, biomass.density.area2}

area2poly.dens <- area2.poly %>%
  group_by(Year, Month, Season, tim_stp, date, clstr_g, Area_id, Area_km2, geometry) %>%
  summarise(CtchWgL = sum(CtchWgL), .groups = "keep") %>%
  mutate(Density = CtchWgL/Area_km2, YearMon = paste0(Year, "-", sprintf("%02d", Month))) %>%
  mutate(YearMon = as.factor(YearMon)) %>%
  ungroup() %>%
  mutate(FID = row_number(.))

View(area2poly.dens)

```

# Fit initial sdmTMB

## First create a mesh

```{r, area2.mesh}

# Extract polygon centers
centroids <-  area2poly.dens %>%
  st_centroid() %>%
  mutate(X = st_coordinates(.)[,1],
         Y = st_coordinates(.)[,2]) %>%
  st_drop_geometry()

plot(centroids$X, centroids$Y)  

# Get summary table for nearest neighbor
library(spatstat)
coords <- cbind(centroids$X, centroids$Y)
nn_dist <- nndist(coords)
summary(nn_dist)

# Set cuttoff to 2/3 distance (mean or median - choose median if strong outliers)
## This is informed by the SPDE theory about mesh resolution relative to spatial 
## range (from Lindgren et al. 2011 and related papers) -- to verify against ChatGPT

cutoff <- 5972.9*(2/3)
cutoff

# 500 m
mesh005 <- make_mesh(centroids, xy_cols = c("X", "Y"), cutoff = 500)
plot(mesh005)
points(centroids$X, centroids$Y, col = "red", pch = 19, cex = 0.1)

# 1 km
mesh01 <- make_mesh(centroids, xy_cols = c("X", "Y"), cutoff = 1000)
plot(mesh01)
points(centroids$X, centroids$Y, col = "red", pch = 19, cex = 0.1)

# 2 km
mesh02 <- make_mesh(centroids, xy_cols = c("X", "Y"), cutoff = 2000) 
plot(mesh02)
points(centroids$X, centroids$Y, col = "red", pch = 19, cex = 0.1)

# 5 km
mesh05 <- make_mesh(centroids, xy_cols = c("X", "Y"), cutoff = 5000)
plot(mesh05)
points(centroids$X, centroids$Y, col = "red", pch = 19, cex = 0.1)

# 10 km
mesh10 <- make_mesh(centroids, xy_cols = c("X", "Y"), cutoff = 10000)  
plot(mesh10)
points(centroids$X, centroids$Y, col = "red", pch = 19, cex = 0.1)

# 15 km
mesh15 <- make_mesh(centroids, xy_cols = c("X", "Y"), cutoff = 15000)  
plot(mesh15)
points(centroids$X, centroids$Y, col = "red", pch = 19, cex = 0.1)

# 20 km
mesh20 <- make_mesh(centroids, xy_cols = c("X", "Y"), cutoff = 20000)  
plot(mesh20)
points(centroids$X, centroids$Y, col = "red", pch = 19, cex = 0.1)

# 25 km
mesh25 <- make_mesh(centroids, xy_cols = c("X", "Y"), cutoff = 25000)
plot(mesh25)
points(centroids$X, centroids$Y, col = "red", pch = 19, cex = 0.1)

# 2/3 median nearest neighbor distance
mesh.median <- make_mesh(centroids, xy_cols = c("X", "Y"), cutoff = cutoff)  
plot(mesh.median)
points(centroids$X, centroids$Y, col = "red", pch = 19, cex = 0.1)

# round to nearest km from 2/3 median nearest neighbor distance
mesh.median.mod <- make_mesh(centroids, xy_cols = c("X", "Y"), cutoff = 4000)  
plot(mesh.median.mod)
points(centroids$X, centroids$Y, col = "red", pch = 19, cex = 0.1)

```

```{r}

# 4km mesh and Year/Month
m1 <- sdmTMB(
    data = centroids,
    formula = Density ~ 1,
    mesh = mesh.median.mod,
    family = tweedie(link = "log"),
    spatial = "on",
    time = "YearMon",
    spatiotemporal = "iid"
  )

summary(m1)
sanity(m1)

# Check gradients
m1$gradients  # should be all < ~0.001

# Check for parameter issues
m1$sd_report  # look for NA/NaN

# Visual check of random field variances
m1$sd_report$diag.cov.random

```

nlminb_loops

    Controls how many times to re-run the optimizer (nlminb) from the current best estimate.

    The optimizer sometimes gets close to the solution but not close enough. Running it again can "nudge" it toward the correct minimum.

    Typical values: 1 (default), 2â€“3 for better convergence.

ðŸ“Œ Think of this as a way to refine the fit by looping through the optimizer multiple times.

ðŸ§® newton_loops

    Runs extra Newton-Raphson refinement steps after the optimizer is done, to improve the Hessian matrix (used to estimate standard errors and check convergence).

    This is especially helpful when the Hessian is not positive definite, which is exactly the problem youâ€™re encountering.

    Typical values: 1â€“5.

ðŸ“Œ Think of this as a way to clean up numerical issues and get a better estimate of uncertainty (standard errors, covariances, etc).

```{r}

# 4km mesh and Year/Month
m2 <- sdmTMB(
    data = centroids,
    formula = Density ~ 1,
    mesh = mesh.median.mod,
    family = tweedie(link = "log"),
    spatial = "on",
    time = "YearMon",
    spatiotemporal = "iid",
    nlminb_loops = 2,
    newton_loops = 1
  )

```


```{r}
# 4km mesh and Year/Season
m2 <- sdmTMB(
    data = centroids,
    formula = Density ~ 1, k = 5,
    mesh = mesh.median.mod,
    family = tweedie(link = "log"),
    spatial = "on",
    time = "YearMon",
    spatiotemporal = "iid"
  )

summary(m2)
sanity(m2)

# 10km mesh & Year/Month
m3 <- sdmTMB(
    data = centroids,
    formula = Density ~ 1,
    mesh = mesh10,
    family = tweedie(link = "log"),
    spatial = "on",
    time = "YearMon",
    spatiotemporal = "iid"
  )

summary(m3)
sanity(m3)



```

